<!DOCTYPE html>
<html>

<head>
    <title>Leaflet Snap to WMS Layer Example</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <!-- Leaflet WMS JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.wms.min.js"></script>

    <!-- Leaflet Draw CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw/dist/leaflet.draw.css" />


    <!-- Leaflet Draw JavaScript -->
    <script src="https://unpkg.com/leaflet-draw/dist/leaflet.draw.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="libs/leaflet.geometryutil.js"></script>


    <script src="libs/turf.min.js"></script>

    <style>
        #map {
            height: 800px;
        }
    </style>
</head>

<body>
    <div id="map"></div>

    <script>
        var map = L.map("map", {}).setView([18.52, 73.895], 12, L.CRS.EPSG4326);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 30,
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        var Village_Boundary = L.tileLayer.wms("https://portal.geopulsea.com/geoserver/AutoDCR/wms", {
            layers: "Village_Boundary",
            format: "image/png",
            transparent: true,
            tiled: true,
            version: "1.1.0",
            opacity: 1,
            maxZoom: 30,
        }).addTo(map);

        var Exist_road = L.tileLayer.wms("https://portal.geopulsea.com/geoserver/pmc/wms", {
            layers: "Exist_Road",
            format: "image/png",
            transparent: true,
            tiled: true,
            version: "1.1.0",
            opacity: 1,
            maxZoom: 30,
        }).addTo(map);

        // pmc:Exist_Road
        var drawnItems = L.featureGroup().addTo(map);

        var drawControl = new L.Control.Draw({
            draw: {
                polyline: true,
                polygon: true,
                marker: true,
                circle: false,
                rectangle: false,

            },
            edit: {
                featureGroup: drawnItems,

            }
        });
        map.addControl(drawControl);

        map.on('draw:created', function (e) {
            var layer = e.layer;
            console.log("heheeh")
            drawnItems.addLayer(layer);
        });

        map.on('draw:edited', function (e) {
            var layers = e.layers;
            console.log("suyog")
            layers.eachLayer(function (layer) {
                // Do whatever you need with the edited layers
            });
        });

        // map.on('mousemove', function (e) {
        //     // console.log(e, "yyy")
        //     // layer.bindPopup( e.latlng);
        //     var latlng = e.latlng;

        //     var turfPoint = turf.point([latlng.lng, latlng.lat]);

        //     // Create a buffer around the point with a radius of 100 meters
        //     var buffered = turf.buffer(turfPoint, 0.1, { units: 'kilometers' });

        //     // Get the bounding box of the buffered area
        //     // Assuming bbox is the bounding box of the Village_Boundary layer
        //     var bbox = turf.bbox(buffered);
        //     var bboxString = bbox.join(',');
        //     // var bounds = bbox.toBBoxString();
        //     // Create a Leaflet rectangle using the bounding box

        //     var rectangle = L.rectangle([
        //         [bbox[1], bbox[0]],
        //         [bbox[3], bbox[2]]
        //     ], { color: 'red', weight: 2, fillOpacity: 0.2 });

        //     var urls = "https://portal.geopulsea.com//geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=AutoDCR:Village_Boundary"+"&propertyName=extension,geom&bbox="+bboxString +"&outputFormat=application/json";


        //     $.getJSON(urls, function (data) {


        //     if (data && data.features && data.features.length > 0) {
        //         console.log(data);

        //         var intersectedFeatures = [];
        //         data.features.forEach(function (feature) {
        //             var intersectedFeature = turf.intersect(feature, rectangle);
        //             if (intersectedFeature && intersectedFeature.geometry.type !== 'GeometryCollection') {
        //                 // Copy the properties from the original feature to the intersected feature
        //                 intersectedFeature.properties = feature.properties;
        //                 intersectedFeatures.push(intersectedFeature);
        //             }
        //         });
        //         var intersectedLayer = L.geoJSON(intersectedFeatures, {
        //             style: {
        //                 color: 'red',
        //                 weight: 2
        //             }
        //         });
        //         intersectedLayer.addTo(map);
        //         intersectedLayer.eachLayer(function (layer) {
        //             var properties = layer.feature.properties;
        //             var area = turf.area(layer.feature);
        //             layer.bindPopup(`Area: ${area.toFixed(2)} sq meters<br>Properties: ${JSON.stringify(properties)}`);
        //         });



        //         var cqlFilter = 'INTERSECTS(geometry, ' + bboxString + ')';
        //         Village_Boundary.setParams({
        //              cql_filter: cqlFilter,
        //              styles: "Highlight_polygon"
        //              }).addTo(map);

        //              FitbouCustomiseRevenue(cqlFilter)

        //     }
        //     else{
        //         console.log("no data");
        //     }
        // });

        // });




        function FitbouCustomiseRevenue(filter) {
            layers = ["AutoDCR:Village_Boundary"];
            layers.forEach(function (layerName) {
                var urlm =
                    "https://portal.geopulsea.com//geoserver/ows?service=WFS&version=1.0.0&request=GetFeature&typeName=" +
                    layerName +
                    "&CQL_FILTER=" +
                    filter +
                    "&outputFormat=application/json";
                $.getJSON(urlm, function (data) {
                    geojson = L.geoJson(data, {});
                    map.fitBounds(geojson.getBounds());
                });
            });
        }

        var wmsLayer = L.tileLayer.wms('https://portal.geopulsea.com//geoserver/ows?', {
            layers: 'AutoDCR:Village_Boundary',
            format: 'image/png',
            transparent: true
        }).addTo(map);



        // var pointMarker;

        // map.on('mousemove', function (e) {
        //     var url = 'https://portal.geopulsea.com/geoserver/ows?service=WMS&version=1.1.1&request=GetFeatureInfo&transparent=true&format=image/png&info_format=application/json&srs=EPSG:4326&bbox=' + map.getBounds().toBBoxString() + '&width=' + map.getSize().x + '&height=' + map.getSize().y + '&layers=AutoDCR:Village_Boundary&query_layers=AutoDCR:Village_Boundary&feature_count=10&x=' + Math.round(e.containerPoint.x) + '&y=' + Math.round(e.containerPoint.y);

        //     if (url) {
        //         fetch(url)
        //             .then(response => response.json())
        //             .then(data => {
        //                 if (data.features && data.features.length > 0) {
           
        //                     var clickedPoint = e.latlng;
        //                     if (pointMarker) {
        //                         map.removeLayer(pointMarker);
        //                     }
        //                     var nearestBoundary = getNearestBoundary(data.features, clickedPoint);
        //                     pointMarker = L.circleMarker(nearestBoundary, { radius: 2.5, color: 'blue' }).addTo(map).bindPopup('Closest point on boundary');
        //                 }
        //             });
        //     }
        // });

        // var lastClosestMarker = null;
        // function getNearestBoundary(features, clickedPoint) {
        //     // Remove the last closest point marker if it exists
        //     if (lastClosestMarker) {
        //         map.removeLayer(lastClosestMarker);
        //     }
        //     features.forEach(function (feature) {
        //         var boundary = feature.geometry.coordinates[0];
        //         var closestToBoundary = L.GeometryUtil.closest(map, boundary, [clickedPoint.lng, clickedPoint.lat]);
        //         var closestPoint = L.latLng(closestToBoundary.lng, closestToBoundary.lat);// Swap lng and lat
        //         lastClosestMarker = closestPoint            
        //     });
        //     return lastClosestMarker
        // }

        var pointMarker;

map.on('mousemove', function (e) {
    var url = 'https://portal.geopulsea.com/geoserver/ows?service=WMS&version=1.1.1&request=GetFeatureInfo&transparent=true&format=image/png&info_format=application/json&srs=EPSG:4326&bbox=' + map.getBounds().toBBoxString() + '&width=' + map.getSize().x + '&height=' + map.getSize().y + '&layers=pmc:Exist_Road&query_layers=pmc:Exist_Road&feature_count=10&x=' + Math.round(e.containerPoint.x) + '&y=' + Math.round(e.containerPoint.y);

    if (url) {
        // console.log(url)
        fetch(url)
            .then(response => response.json())
            .then(data => {
                if (data.features && data.features.length > 0) {
                    // console.log(data.features,"data.features")
                    var clickedPoint = e.latlng;
                    if (pointMarker) {
                        map.removeLayer(pointMarker);
                    }
                    var nearestBoundary = getNearestBoundary(data.features, clickedPoint);
                    pointMarker = L.circleMarker(nearestBoundary, { radius: 2.5, color: 'blue' }).addTo(map).bindPopup('Closest point on boundary');
                }
            });
    }
});

var lastClosestMarker = null;
function getNearestBoundary(features, clickedPoint) {
    // Remove the last closest point marker if it exists
    if (lastClosestMarker) {
        map.removeLayer(lastClosestMarker);
    }
    features.forEach(function (feature) {
        var boundary = feature.geometry.coordinates[0];
        var closestToBoundary = L.GeometryUtil.closest(map, boundary, [clickedPoint.lng, clickedPoint.lat]);
        var closestPoint = L.latLng(closestToBoundary.lng, closestToBoundary.lat);// Swap lng and lat
        lastClosestMarker = closestPoint            
    });
    return lastClosestMarker
}



    </script>
</body>

</html>